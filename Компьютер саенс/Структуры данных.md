### Определение
**Структура данных** — это контейнер, который хранит данные в определенном макете. Этот «макет» позволяет структуре данных быть эффективной в некоторых операциях и неэффективной в других.

Структуры данных делятся на 2 типа:
+ **Линейные**
+ **Нелинейные**

### Линейные
В линейной структуре данных элементы образуют последовательность или линейный список, обход узлов линеен.

#### Массивы
Массив — это самая простая и широко используемая структура данных. Другие структуры данных, такие как стеки и очереди, являются производными от массивов.  
  
Изображение простого массива размера 4, содержащего элементы (1, 2, 3 и 4).

![[ivvjkxghqmm87r3ceaup-sjaxa8.jpeg]]

Каждому элементу данных присваивается положительное числовое значение (индекс), который соответствует позиции элемента в массиве. Большинство языков определяют начальный индекс массива как 0.

Массивы бывают одномерными и многомерными (массив в массиве).

**Основные операции**:
-   Insert-вставляет элемент по заданному индексу
-   Get-возвращает элемент по заданному индексу
-   Delete-удаление элемента по заданному индексу
-   Size-получить общее количество элементов в массиве

#### Стеки
Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).  
  
Примером стека может быть куча книг, расположенных в вертикальном порядке. Для того, чтобы получить книгу, которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней. Так работает метод LIFO (Last In First Out). Функция «Отменить» в приложениях работает по LIFO.  
  
Изображение стека, в три элемента (1, 2 и 3), где 3 находится наверху и будет удален первым.

![[vupphsidgppdcjzld_h6haiohv8.jpeg]]

**Основные операции**:
-   Push-вставляет элемент сверху
-   Pop-возвращает верхний элемент после удаления из стека
-   isEmpty-возвращает true, если стек пуст
-   Top-возвращает верхний элемент без удаления из стека

#### Очереди
Подобно стекам, очередь — хранит элемент последовательным образом. Существенное отличие от стека – использование FIFO (First in First Out) вместо LIFO.  
  
Пример очереди – очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.  
  
Изображение очереди, в четыре элемента (1, 2, 3 и 4), где 1 находится наверху и будет удален первым

![[vsvzd-nhfbt8lgqygo_n6kevota.jpeg]]

**Основные операции**:
-   Enqueue — вставляет элемент в конец очереди
-   Dequeue — удаляет элемент из начала очереди
-   isEmpty — возвращает значение true, если очередь пуста
-   Top — возвращает первый элемент очереди

#### Связанный список

Связанный список – массив где каждый элемент является отдельным объектом и состоит из двух элементов – данных и ссылки на следующий узел.  
  
Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

Бывают однонаправленными, двунаправленными и кольцевыми.

Самое частое, линейный однонаправленный список. Пример – файловая система.

![[aitc0cr61ubeesbbvhicyx5xp3o.jpeg]]

**Основные операции**:
-   InsertAtEnd — Вставка заданного элемента в конец списка
-   InsertAtHead — Вставка элемента в начало списка
-   Delete — удаляет заданный элемент из списка
-   DeleteAtHead — удаляет первый элемент списка
-   Search — возвращает заданный элемент из списка
-   isEmpty — возвращает True, если связанный список пуст

#### Хэш таблицы

Хэширование — это процесс, используемый для уникальной идентификации объектов и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе).  
  
Объект хранится в виде пары «ключ-значение», а коллекция таких элементов называется «словарем». Каждый объект можно найти с помощью этого ключа.  
  
По сути это массив, в котором ключ представлен в виде хеш-функции.  
  
Пример сопоставления хеша в массиве. Индекс этого массива вычисляется через хэш-функцию.

![[gcm7twadesefi0xzksi9e4gnjbw.jpeg]]

### Нелинейные
В нелинейной структуре данных обход узлов нелинейный, а данные не последовательны.

#### Графы
Граф-это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).

![[9iulcveuitlldkx6itsyprjcmhg.jpeg]]

Бывают следующих видов:
- **Ориентированный**, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.  
- **Неориентированные**, к каждому из ребер можно осуществлять переход в обоих направлениях.  

**Общие алгоритмы обхода графа**:
-   Поиск в ширину – обход по уровням
-   Поиск в глубину – обход по вершинам

#### Деревья

Дерево-это иерархическая структура данных, состоящая из узлов (вершин) и ребер (дуг). Деревья по сути связанные графы без циклов.  
  
Древовидные структуры везде и всюду. Дерево скилов в играх знают все.

Пример:

![[7uicvvfrp5r11e6a_ysnnueynu8.jpeg]]

Типы деревьев  

-   N дерево
-   Сбалансированное дерево
-   Бинарное дерево
-   Дерево Бинарного Поиска
-   AVL дерево
-   2-3-4 деревья

Бинарное дерево — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями.

Пример:

![[772ac8a1ed9c4abb862c036a2113a196.png]]

Бинарное дерево поиска — это бинарное дерево, обладающее дополнительными свойствами: значение левого потомка меньше значения родителя, а значение правого потомка больше значения родителя для каждого узла дерева. То есть, данные в бинарном дереве поиска хранятся в отсортированном виде. При каждой операции вставки нового или удаления существующего узла отсортированный порядок дерева сохраняется. При поиске элемента сравнивается искомое значение с корнем. Если искомое больше корня, то поиск продолжается в правом потомке корня, если меньше, то в левом, если равно, то значение найдено и поиск прекращается.

![[7f3d0251cd5f42e8a0a1f3aec41da199.png]]

