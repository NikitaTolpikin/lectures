### Введение
Мы полагаемся на такие инструменты, как компиляция и интерпретация, чтобы преобразовать наш код в форму, понятную компьютеру. Код может быть исполнен нативно, в операционной системе после конвертации в машинный (путём компиляции) или же исполняться построчно другой программой, которая делает это вместо ОС (интерпретатор).

#### Компилируемые языки
Компилируемый язык — это такой язык, что программа, будучи скомпилированной, содержит инструкции целевой машины. 

Существует специальные приложения, известные как **компиляторы**. Они принимают программу, которую вы написали. Затем анализируют и разбирают каждую часть программы и строят машинный код для процессора. Часто его также называют _машинным кодом_.

На одном из этапов процесса обработки задействуется компоновщик, принимающий части программы, которые отдельно были преобразованы в объектный код, и связывает их в один исполняемый файл.

![[compilationdiagram-010238.webp]]

Конечным элементом этого процесса является **исполняемый файл**. 
Когда вы запускаете или сообщаете компьютеру, что это исполняемый файл, он берет первую же инструкцию из него, не фильтрует, не преобразует, а сразу запускает программу и выполняет ее без какого-либо дополнительного преобразования. 

Это ключевая характеристика процесса компиляции - его результат должен быть исполняемым файлом, не требующим дополнительного перевода, чтобы процессор мог начать выполнять первую инструкцию и все следующие за ней.

Основные недостатки:
1. Отсутствие высокоуровневых фич: Сборщик мусора, [[Типизация#Динамическая типизация|Динамическая типизация]] и др.
2. Машинный код компилируется под определенный процессор -> нет кроссплатформенности

Основные преимущества:
1. Программа не требует дополнительных библиотек или программ
2. Скорость выполнения

Примеры компилируемых языков: [[C]], [[C++]], [[Rust]], [[Go]]

#### Интерпретируемые языки

Интерпретатор - это исполняемый файл, который поэтапно читает программу, а затем обрабатывает, сразу выполняя ее инструкции.

Другими словами, программа-интерпретатор выполняет программу поэтапно как часть собственного исполняемого файла. _Машинный код_ не передается процессору, интерпретатор сам является объектным кодом, построенным таким образом, чтобы его можно было вызвать в определенное время.

![[interpretationdiagram-010239.webp]]

В отличии от _компилятора_, _интерпретатор_ всегда должен быть под рукой, чтобы мы могли вызвать его и запустить нашу программу. В некотором смысле интерпретатор становится процессором. 

Программы, написанные для интерпретации, называются «скриптами», потому что они являются сценариями действий для другой программы, а не прямым машинным кодом.

Основные недостатки:
- Скорость выполнения программы
- Необходимость в _интерпретаторе_ 

Основные преимущества:
- Высокоуровневые фичи: Сборщик мусора, [[Типизация#Динамическая типизация|Динамическая типизация]] и др.
- Кроссплатформенность

В настоящее время проигрыш в скорости удается нивелировать при помощи **JIT(Just In Time)-компиляторов** в составе _интерпретатора_.  JIT-компиляция позволяет ускорить процесс благодаря переводу часто используемых последовательностей инструкции в _машинный код_.

Примеры интерпретируемых языков: [[Python]], [[Ruby]], [[PHP]]

#### Байткод-языки
Байткод-языки — это такие языки, которые используют для исполнения кода как компиляцию, так и интерпретацию. Мне известно два таких семейства языков [[Java]] и [[C Sharp]] с [[C++]].

Основной смысл состоит в том, что изначальный программный код компилируется (то есть переводится весь разом) в _байткод_. 

_Байткод_ — это набор инструкций, созданный для эффективного исполнения интерпретатором и состоящий из компактных числовых кодов, констант и ссылок на память.

Этот _байткод_ считывается **специальным _интерпретатором_** и переводится в _машинный код_. Такие интерпретаторы уникальны:
- Java - JVM (Java Virtual Machine)
- C Sharp - CLR (Common Language Runtime)

При компиляции кода в _байткод_ происходит задержка, но дальнейшая скорость исполнения значительно возрастает в силу оптимизации _байткода_. В итоге получаем исполняемый файл в _машинном коде_. Однако не для всех процессоров он подойдет, поэтому обычно скомпилированные программы хранятся в байт-коде. 

Все что нужно, чтобы их исполнить - иметь на машине JVM или CLR. CLR распространяется вместе со всеми ОС, JVM надо поставить самому.

Основные недостатки:
- Скорость компиляции
- На компьютере должен быть установлен JVM или CLR

Основные преимущества:
- Высокоуровневые фичи: Сборщик мусора, [[Типизация#Динамическая типизация|Динамическая типизация]] и др.
- Кроссплатформенность
- Скорость выполнения


